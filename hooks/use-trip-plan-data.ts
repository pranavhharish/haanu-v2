"use client"

import { useState, useEffect, useCallback } from "react"
import { supabase } from "@/lib/supabase"
import type { Trip, Activity, ChatMessage } from "@/lib/supabase"
import type { RealtimeChannel } from "@supabase/supabase-js"

export interface TripPlanState {
  trip: Trip | null
  activities: Activity[]
  chatMessages: ChatMessage[]
  loading: boolean
  error: string | null
  isGeneratingItinerary: boolean
  hasAutoGenerated: boolean
}

export function useTripPlanData(tripId: string | null) {
  const [state, setState] = useState<TripPlanState>({
    trip: null,
    activities: [],
    chatMessages: [],
    loading: true,
    error: null,
    isGeneratingItinerary: false,
    hasAutoGenerated: false,
  })

  const updateState = useCallback((updates: Partial<TripPlanState>) => {
    setState((prev) => ({ ...prev, ...updates }))
  }, [])

  const fetchTripDetails = useCallback(async () => {
    if (!tripId) {
      updateState({ error: "Trip ID is required.", loading: false })
      return
    }
    try {
      const { data, error: tripError } = await supabase.from("trips").select("*").eq("id", tripId).single()

      if (tripError) throw tripError
      updateState({ trip: data })
      return data
    } catch (err: any) {
      console.error("Error fetching trip details:", err)
      updateState({ error: `Failed to fetch trip details: ${err.message}`, trip: null })
      return null
    }
  }, [tripId, updateState])

  const fetchActivities = useCallback(async () => {
    if (!tripId) return []
    try {
      const { data, error: activitiesError } = await supabase
        .from("activities")
        .select("*")
        .eq("trip_id", tripId)
        .order("day_number", { ascending: true })
        .order("order", { ascending: true })

      if (activitiesError) throw activitiesError
      updateState({ activities: data || [] })
      return data || []
    } catch (err: any) {
      console.error("Error fetching activities:", err)
      updateState({ error: `Failed to fetch activities: ${err.message}`, activities: [] })
      return []
    }
  }, [tripId, updateState])

  const fetchChatMessages = useCallback(async () => {
    if (!tripId) return []
    try {
      const { data, error: messagesError } = await supabase
        .from("chat_messages")
        .select("*")
        .eq("trip_id", tripId)
        .order("created_at", { ascending: true })

      if (messagesError) throw messagesError
      updateState({ chatMessages: data || [] })
      return data || []
    } catch (err: any) {
      console.error("Error fetching chat messages:", err)
      updateState({ error: `Failed to fetch chat messages: ${err.message}`, chatMessages: [] })
      return []
    }
  }, [tripId, updateState])

  const addActivity = async (activityData: Omit<Activity, "id" | "trip_id" | "created_at" | "updated_at">) => {
    if (!tripId) {
      console.error("Cannot add activity without tripId")
      return
    }
    try {
      const { data: userSession } = await supabase.auth.getUser()
      if (!userSession.user) throw new Error("User not authenticated")

      const newActivityData = { ...activityData, trip_id: tripId }
      const { data, error: insertError } = await supabase.from("activities").insert(newActivityData).select().single()

      if (insertError) throw insertError

      // Optimistically update state
      updateState({
        activities: [...state.activities, data].sort((a, b) => {
          if (a.day_number !== b.day_number) return a.day_number - b.day_number
          return (a.order || 0) - (b.order || 0)
        }),
      })

      console.log("Activity added:", data)
      return data
    } catch (err: any) {
      console.error("Error adding activity:", err)
      updateState({ error: `Failed to add activity: ${err.message}` })
    }
  }

  const updateActivity = async (activityId: string, updates: Partial<Activity>) => {
    try {
      const { data, error: updateError } = await supabase
        .from("activities")
        .update(updates)
        .eq("id", activityId)
        .select()
        .single()

      if (updateError) throw updateError

      // Optimistically update state
      updateState({
        activities: state.activities.map((act) => (act.id === activityId ? data : act)),
      })

      console.log("Activity updated:", data)
      return data
    } catch (err: any) {
      console.error("Error updating activity:", err)
      updateState({ error: `Failed to update activity: ${err.message}` })
    }
  }

  const deleteActivity = async (activityId: string) => {
    try {
      const { error: deleteError } = await supabase.from("activities").delete().eq("id", activityId)
      if (deleteError) throw deleteError

      // Optimistically update state
      updateState({
        activities: state.activities.filter((act) => act.id !== activityId),
      })

      console.log("Activity deleted:", activityId)
    } catch (err: any) {
      console.error("Error deleting activity:", err)
      updateState({ error: `Failed to delete activity: ${err.message}` })
    }
  }

  const addChatMessage = async (messageData: Omit<ChatMessage, "id" | "trip_id" | "created_at">) => {
    if (!tripId) {
      console.error("Cannot add chat message without tripId")
      return
    }
    try {
      const { data: userSession } = await supabase.auth.getUser()
      if (!userSession.user) throw new Error("User not authenticated")

      const newChatMessageData = { ...messageData, trip_id: tripId }
      const { data, error: insertError } = await supabase
        .from("chat_messages")
        .insert(newChatMessageData)
        .select()
        .single()

      if (insertError) throw insertError

      // Optimistically update state
      updateState({
        chatMessages: [...state.chatMessages, data],
      })

      console.log("Chat message added:", data)
      return data
    } catch (err: any) {
      console.error("Error adding chat message:", err)
      updateState({ error: `Failed to add chat message: ${err.message}` })
    }
  }

  const reorderActivities = async (dayNumber: number, reorderedActivityIds: string[]) => {
    if (!tripId) return
    try {
      const updates = reorderedActivityIds.map((activityId, index) =>
        supabase
          .from("activities")
          .update({ order: index, day_number: dayNumber })
          .eq("id", activityId)
          .eq("trip_id", tripId),
      )
      const results = await Promise.all(updates)
      results.forEach((result) => {
        if (result.error) throw result.error
      })

      // Refetch activities to ensure consistency
      await fetchActivities()
      console.log("Activities reordered for day:", dayNumber)
    } catch (err: any) {
      console.error("Error reordering activities:", err)
      updateState({ error: `Failed to reorder activities: ${err.message}` })
    }
  }

  const clearAllActivities = async () => {
    if (!tripId) return
    try {
      const { error } = await supabase.from("activities").delete().eq("trip_id", tripId)
      if (error) throw error

      updateState({ activities: [] })
      console.log("All activities cleared for trip:", tripId)
    } catch (err: any) {
      console.error("Error clearing activities:", err)
      updateState({ error: `Failed to clear activities: ${err.message}` })
    }
  }

  const refetchData = useCallback(async () => {
    if (!tripId) return
    updateState({ loading: true, error: null })

    try {
      await Promise.all([fetchTripDetails(), fetchActivities(), fetchChatMessages()])
    } catch (err) {
      console.error("Error during data refetch:", err)
    } finally {
      updateState({ loading: false })
    }
  }, [tripId, fetchTripDetails, fetchActivities, fetchChatMessages, updateState])

  // Initial data fetch
  useEffect(() => {
    if (!tripId) {
      updateState({ loading: false, error: "No Trip ID provided." })
      return
    }

    updateState({ loading: true, error: null })
    Promise.all([fetchTripDetails(), fetchActivities(), fetchChatMessages()]).finally(() => {
      updateState({ loading: false })
    })

    // Realtime subscriptions
    let activitiesChannel: RealtimeChannel | undefined
    let messagesChannel: RealtimeChannel | undefined

    if (tripId) {
      activitiesChannel = supabase
        .channel(`activities:${tripId}`)
        .on<Activity>(
          "postgres_changes",
          { event: "*", schema: "public", table: "activities", filter: `trip_id=eq.${tripId}` },
          (payload) => {
            console.log("Realtime activity change:", payload)
            fetchActivities()
          },
        )
        .subscribe((status, err) => {
          if (err) console.error("Activities subscription error:", err)
        })

      messagesChannel = supabase
        .channel(`chat_messages:${tripId}`)
        .on<ChatMessage>(
          "postgres_changes",
          { event: "INSERT", schema: "public", table: "chat_messages", filter: `trip_id=eq.${tripId}` },
          (payload) => {
            console.log("Realtime message insert:", payload)
            updateState({
              chatMessages: [...state.chatMessages, payload.new as ChatMessage],
            })
          },
        )
        .subscribe((status, err) => {
          if (err) console.error("Chat messages subscription error:", err)
        })
    }

    return () => {
      if (activitiesChannel) supabase.removeChannel(activitiesChannel)
      if (messagesChannel) supabase.removeChannel(messagesChannel)
    }
  }, [tripId])

  return {
    ...state,
    addActivity,
    updateActivity,
    deleteActivity,
    addChatMessage,
    reorderActivities,
    clearAllActivities,
    refetchData,
    setIsGeneratingItinerary: (isGenerating: boolean) => updateState({ isGeneratingItinerary: isGenerating }),
    setHasAutoGenerated: (hasGenerated: boolean) => updateState({ hasAutoGenerated: hasGenerated }),
  }
}
